
# Django setup
```sh
alias py="python"
```
## Create python virtual environement
Python venv, short for "Python virtual environment," is a tool that allows you to create isolated environments for Python projects. Each virtual environment has its own Python binary and can have its own set of installed packages, independent of the system-wide Python installation and other virtual environments.

Here's why Python developers use virtual environments like venv:

1. **Isolation**: Virtual environments isolate your project's dependencies from other projects and the system-wide Python installation. This prevents conflicts between different versions of packages required by different projects.
2. **Dependency Management**: With venv, you can easily manage dependencies for each project. You can install specific versions of packages and keep track of them using a `requirements.txt` file or similar.
3. **Reproducibility**: Virtual environments ensure that your project can be easily reproduced on different machines. By specifying the exact versions of dependencies in the environment, you ensure that anyone who runs your project gets the same environment setup.
4. **Testing**: Virtual environments are useful for testing your projects in isolated environments. You can create a clean environment for testing and ensure that your tests don't interfere with the system or other projects.
5. **Security**: Virtual environments can enhance the security of your projects by isolating them from potentially harmful or conflicting packages in the system-wide Python installation.

Overall, Python venv is a valuable tool for managing dependencies, ensuring reproducibility, and maintaining project isolation, which are crucial aspects of Python development, especially in complex projects with multiple dependencies.
- create: `py -m venv <venv_dir_name>` 
- activate: `source <venv_dir_name>/bin/activate` (to quit: `deactivate`)
## Install
`py -m pip install Django` **UPD**: see **Bootstrap integration** section!
To verify that it is well installed:
```
$> py
>>> import Django
```
if It's not installed `python` will throw an exception
## Init project
`django-admin startproject <prj name>` - initializes the basic structure and files needed for a Django project, including settings, URLs, and a manage.py script for administrative tasks.
Within this new directory, Django creates several files and directories:
- `manage.py`: This is a Python script that acts as a command-line interface for various administrative tasks related to your Django project, such as running the development server, creating database migrations, and more.
- `project_name/`: This directory contains the actual Django project. Inside this directory, you'll find files like `settings.py`, `urls.py`, and `wsgi.py`.
- `wsgi.py`: This file is used for deploying your Django project using WSGI (Web Server Gateway Interface) servers like Gunicorn or uWSGI.
- `urls.py`: This file defines the URL patterns for your Django project, mapping URLs to views.
- `settings.py`: This file contains configuration settings for your Django project, including database configuration, static files settings, middleware configuration, and more.
## Start server
In project main directory created in previous step:
`py manage.py runserver`
This starts web server, by default running on http://localhost:8000/
*At this point it will be like starting default nginx server*
## Init application
`py manage.py startapp <app_name>` - create a new Django app within an existing Django project.
When you run `manage.py startapp app_name`, the following happens:
1. Django creates a new directory with the specified app name (`app_name`) within your project's directory structure. This directory will contain all the files and directories necessary for your Django app.
2. Within this new app directory, Django creates several files and directories:
    - `models.py`: This file is where you define your app's data models using Django's Object-Relational Mapping (ORM) system. Models represent database tables and their relationships.
    - `views.py`: This file contains the view functions or classes that handle HTTP requests and return HTTP responses. Views interact with models to fetch data and render templates to generate HTML responses.
    - `urls.py`: This file is used to define URL patterns specific to your app. You can map URL patterns to views within your app using this file.
    - `admin.py`: This file is used to register your app's models with the Django admin interface, allowing you to manage your app's data through the Django admin site.
    - `apps.py`: This file contains configuration for your app, such as its name and any application-specific configuration options.
    - `migrations/`: This directory is used to store database migrations for your app. Migrations are scripts generated by Django to manage changes to your app's database schema over time.
*Applications are essentially like **server** blocks in nginx*
## Outview
At the end, the app setup looks like this:
```
my_project/
├── manage.py
├── my_project/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── my_app/
    ├── migrations/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── models.py
    ├── tests.py
    └── views.py
```
# How it works
1. **Django's URL Dispatcher Resolves the URL**:
    - Django's URL dispatcher, defined in the project's `urls.py` file, matches the requested URL to a corresponding view function or class.
    - The URL dispatcher uses regular expressions or simple string matching to determine which URL pattern matches the requested URL path.
2. **URL Pattern Matches to View Function or Class**:
    - Once the URL dispatcher finds a matching URL pattern, it calls the associated view function or class defined in the `urls.py` file.
    - In the project's `urls.py`, you define the URL patterns and map them to view functions or classes provided by the app.
3. **View Function or Class Executes**:
    - Django calls the associated view function or class to handle the incoming request.
    - The view function or class performs any necessary processing, such as fetching data from a database, processing form submissions, or rendering a template.
4. **View Function or Class Logic**:
    - Inside the view function or class, you write the logic to handle the request and generate a response.
    - This logic may involve interacting with models, querying the database, processing form data, or any other business logic specific to your application.
5. **Data Processing and Business Logic**:
    - Within the view function or class, you can access request data, such as GET or POST parameters, headers, or session data.
    - You process this data, perform any required operations (e.g., data validation, authentication), and prepare the data for rendering or further processing.
6. **Response Generation**:
    - After processing the request, the view function or class generates an HTTP response object.
    - This response object typically includes an HTTP status code, headers, and optionally a body containing the content to be sent back to the client.
7. **Rendering Templates or Returning Data**:
    - Depending on the nature of the response, the view function or class may render a template using Django's templating engine or return data directly (e.g., JSON response).
    - If rendering a template, the view passes data to the template context, which is then rendered into HTML for the response body.
8. **HTTP Response Object Returned**:
    - The view function or class returns the HTTP response object to Django's request-response cycle.
    - This response object is then passed back to the WSGI server, which handles sending the response back to the client.
9. **Server Writes Response Data**:
    - The WSGI server writes the HTTP response data generated by Django to the socket, sending it back to the client.
    - The response data includes the response line, headers, and message body, if applicable.
10. **Client Receives Response**:
    - The client receives the HTTP response from the server over the established TCP connection.
    - The client's browser processes the response, rendering any HTML content received and possibly executing any embedded JavaScript.
# Simple project setup
## [URLs](https://docs.djangoproject.com/en/5.0/topics/http/urls/)
### Project-level
`<prj name>/<prj name>/urls.py`
- The project-level `urls.py` serves as the central routing configuration for the entire Django project.
- This file defines the top-level routing structure for the entire project.
- It typically includes URL patterns for the project's various apps and may also include other project-wide URLs.
```python
	from django.contrib import admin
	from django.urls import include, path
	
	urlpatterns = [
		path('', include('<app name>.urls')),
	]
```
### App-level :
`<prj name>/<app name>/urls.py`
- The app-level `urls.py` file serves as a routing configuration specific to the app.
- This file encapsulates the URL routing logic specific to the app, allowing the app to be reusable and pluggable in other projects.
- It defines URL patterns related to the functionality provided by the app.
```python
from django.urls import path
from . import views

urlpatterns = [
	path('location_name/', views.location_name, name='location_name'),
]
```
## [Views](https://docs.djangoproject.com/en/5.0/topics/http/views/)
Django views are Python functions that takes http requests and returns http response, like HTML documents.
A web page that uses Django is full of views with different tasks and missions.
Views are usually put in a file called `views.py` located on your app's folder.
`<prj name>/<app name>/views.py`
```python
from django.shortcuts import render
from django.http import HttpResponse

# return 200 "Hello World!"
def location_name(request):
	return HttpResponse("Hello world!")
```
## It's all like NGINX!
That's basically like putting this in `nginx.conf`
```nginx
location /location_name/ {
	return 200 "Hello, World!";
}
```
## [Models](https://docs.djangoproject.com/en/5.0/topics/db/models/)
Web applications are storing all data in databases (*table*). On the application's side the data is represented as class with fields (*model*), on the database's side - as entry in the table with columns.
At this point DB used is *SQLite*, a database emulator for the test purposes, essentially.
### Descibe a model
In order to add database support to the app - we need to introduce models. As an example, let the model be *User*.

In `<prj name>/<app name>/models.py`:
```python
from django.db import models

class User(models.Model):
	firstname = models.CharField(max_length=255)
	lastname = models.CharField(max_length=255)
```
### Create [migration](https://docs.djangoproject.com/en/5.0/topics/migrations/)
Now when we have described a Model in the `models.py` file, the next step is to make a migration.
Migrations are Django’s way of propagating changes you make to your models (adding a field, deleting a model, etc.) into your database schema.
At `<prj name>`: `py manage.py makemigrations <app name>`
This will auto generate script that will actually perform manipulations with DB. In the case with **User**, it will look like this:
`<prj name>/<app name>/migrations/0001_initial.py`
```python
from django.db import migrations, models

class Migration(migrations.Migration):
	initial = True
	dependencies = [
	]
	
	operations = [
		migrations.CreateModel(
			name='User',
			fields=[
				('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
				('firstname', models.CharField(max_length=255)),
				('lastname', models.CharField(max_length=255)),
			],
		),
	]
```
### Prepare the DB itself
Now, we must run a command to actually create the table in the database: `py manage.py migrate`.
That's what Django would do for us:
```sql
CREATE TABLE "<app name>_user" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "firstname" varchar(255) NOT NULL, "lastname" varchar(255) NOT NULL);
COMMIT;
```
When table is ready, we can put some data in it. Of course, we can execute raw sql queries but Django has nicer way to make it:
- Enter py shell: `py manage.py shell`
- Import model: `from <app name>.models import User`
- Create an object: `user = User(firstname='Prenom', lastname='Nom')`
- Save changes to DB: `user.save()`
And now the entry is written to the database. To look up it's contents run: `User.objects.all().values()`
## [Templates](https://docs.djangoproject.com/en/5.0/topics/http/views/)
The simplest way to make Django app respond with actual webpages is to use html templates.
### Basic template
For that we need to:
- Create `<prj name>/<app name>/templates` folder with html files in it. Let it be `chart.html`
```html
<!DOCTYPE html>
<html>
<body>

<h1>User chart</h1>
  
<ul>
    <li>Nom Prenom</li>
</ul>

</body>
</html>
```
- Modify `<prj name>/<app name>/views.py`, so it will return an `chart.html` instead of "Hello, World!" string:
```python
from django.http import HttpResponse
from django.template import loader

def chart(request):
	template = loader.get_template('chart.html')
	return HttpResponse(template.render())
```
- Modify `<prj name>/<app name>/urls.py`, to map it with a *chart* view
```python
from django.urls import path
from . import views

urlpatterns = [
	path('chart/', views.chart, name='chart')
]
```
- In order to make server pick up and process templates we need to add our app to application list in `<prj name>/<prj name>/settings.py`:
```python
...
INSTALLED_APPS = [
	'django.contrib.admin',
	'django.contrib.auth',
	'django.contrib.contenttypes',
	'django.contrib.sessions',
	'django.contrib.messages',
	'django.contrib.staticfiles',
	'<app name>'
]
...
```
At this point Django will just send html to the client as it is.
### Dynamic template
Now, let's make Django fill the *chart* with users from the database.
First: add [Django Tags](https://docs.djangoproject.com/en/5.0/topics/templates/#tags) to the html page
In `<prj name>/<app name>/templates/chart.html`:
```django
<!DOCTYPE html>
<html>
<body>

<h1>User chart</h1>
  
<ul>
	{% for x in allusers %}
	    <li>{{ x.firstname }} {{ x.lastname }}</li>
	{% endfor %}
</ul>

</body>
</html>
```
Then - update view, so it will actually put data from the *DB* to the template.
In `<prj name>/<app name>/views.py`:
```python
from django.http import HttpResponse
from django.template import loader
from .models import User

def chart(request):
	allusers = User.objects.all().values()
	template = loader.get_template('chart.html')
	context = {
		'allusers': allusers
	}
return HttpResponse(template.render(context, request))
```
### Parent template
Django provides a way of making a "parent template" that you can include in all pages to do the stuff that is the same in all pages. To use it - create a `templates/parent.html` that would be a blueprint for all derive d templates:
```django
<!DOCTYPE html>
<html>
<head>
  <title>{% block title %}{% endblock %}</title>
</head>
<body>

{% block content %}
{% endblock %}

</body>
</html>
```
And `chart.html` derived from it would look like this:
```django
{% block title %}
User chart
{% endblock %}

{% block content %}
<ul>
	{% for x in allusers %}
	    <li>{{ x.firstname }} {{ x.lastname }}</li>
	{% endfor %}
</ul>
{% endblock %}
```
### Error page template
To set up custom error pages:
- In `<prj name>/<prj name>/settings.py` disable auto-generated debug page:
```python
# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False
# explicitly allow hosts being used. "All" - only for test purposes
ALLOWED_HOSTS = ['*']
```
- Create `<prj name>/<app name>/templates/<error code>.html`. For example `404.html`
# Admin page
- To be able to use admin interface, verify that in `<prj name>/<prj name>/urls.py` admin interface is specified:
```python
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
	path('', include('<app name>.urls')),
	path('admin/', admin.site.urls),
]
```
- To be able to log into the admin application, we need to create a user: `py manage.py createsuperuser`. Then type username, email and password.
- To actually use admin page for **Create Read Update Delete** operations on models - they need to be registered. In ``<prj name>/<app name>/admin.py`:
```python
from django.contrib import admin
from .models import User

admin.site.register(User)
```
# Multi-user project
In this chapter previously created project would be reshaped int something, that looks more like an actual multiplayer browser game.
## Real Users
The `User` class we've made before is in fact unusable, one can't use it for logging in to the any app. In order to do so, Django has pre-created **`User`** class. However, standard **`User`** class obviously lacks data fields needed by the application.
In order to solve this issue we'll make our app-specific `User` extend the standard one.
### Map application's user with `django.contrib.auth.models.User`
#### Disambiguate users
To avoid the confusion, let's rename our model from `User` to `Player`, to avoid further confusion. From now on we'll refer to:
- `django.contrib.auth.models.User` as *User*
- `<app_name>.models.Player` (ex-`User`)  as *Player*
#### Link Player with User
Modify *Player* class - add reference to the *User* class, which particular *Player* would extend and remove all fields that are duplicating ones, which *User* already has. Now, *Player* model should look like this:
```python
from django.contrib.auth.models import User

class Player(models.Model):  
    user = models.OneToOneField(User, on_delete=models.CASCADE)  
    games = models.IntegerField(default=0)  
    wins = models.IntegerField(default=0)  
    loses = models.IntegerField(default=0)  
  
    def __str__(self):  
        return self.user.username  
  
    def get_absolute_url(self):  
        return reverse("user_detail", args=[str(self.user.id)])
```
All data such as `username`, `birth-date` etc. is contained in the *User*, and we can access it from *Player*'s user field.
**`OneToOneField`**: as far as any model is just a database table, and any instance is a particular record - any model's field is a column. `OneToOneField` - is one or the reference types, meaning that to each record in this table there are corresponding record in another table. In particular case - each *Player* references to one corresponding *User*.
**`on_delete=models.CASCADE`**: means that if *Player* record get's erased - corresponding *User* should be erased as well.
#### Automatic *Player* creation using `post_save` signaling
In order to use *Player* as *User*'s extension we need to make sure that when new *User* is created - the associated *Player* gets created and attached to *User* automatically. It is done through the signaling mechanism. Here's how to use [signals](https://docs.djangoproject.com/en/5.0/topics/signals/#module-django.dispatch) for that:
##### Create signal listener
In `<app_name>/signals.py`:
```python
from django.db.models.signals import post_save  
from django.dispatch import receiver  
from django.contrib.auth.models import User  
from .models import Player  
  
  
@receiver(post_save, sender=User)  
def create_player(sender, instance, created, **kwargs):  
    if created:  
        Player.objects.create(user=instance)
```
`create_player` is a callback method. It means, that because it is marked with a  *[@receiver](https://docs.djangoproject.com/en/5.0/topics/signals/#connecting-receiver-functions) decorator*, it will be called when `save()` method will be called on the `User` instance.
In this method we create new instance of `Player` setting it's `user` field with a `User` instance, on which `save()` was called as argument. Sort of a constructor-in-place.
##### Signals registration
In `<app_name>/apps.py`:
```python
# --------- autogenerated upon "py manage.py startapp <app_name>" step  
from django.apps import AppConfig  
  
  
class MiniTranscendenceConfig(AppConfig):  
    name = '<app_name>'  
    default_auto_field = 'django.db.models.BigAutoField'  
  
# ---------   
def ready(self):  
	from . import signals
```
Signal receivers are connected in the [`ready()`](https://docs.djangoproject.com/en/5.0/ref/applications/#django.apps.AppConfig.ready "django.apps.AppConfig.ready") method of application [configuration class](https://docs.djangoproject.com/en/5.0/ref/applications/#configuring-applications-ref). It means, that signals registration happens only after [AppConfig](https://docs.djangoproject.com/en/5.0/ref/applications/#django.apps.AppConfig) is fully loaded. 
### Authentication
Django provides almost everything you need to create authentication pages to handle login, log out, and password management "out of the box". This includes a URL mapper, views and forms, but it does not include the templates — we have to create our own.
#### Set up `accounts/` url mapping
in `<prj name>/<app name>/urls.py` add set of urls for the builtin account actions:
```python
from django.urls import include, path
from . import views

urlpatterns = [
	...
	path('accounts/', include('django.contrib.auth.urls')),
]
```
It will provide whole set of actions for the most common use-cases:
```python
accounts/ login/ [name='login']
accounts/ logout/ [name='logout']
accounts/ password_change/ [name='password_change']
accounts/ password_change/done/ [name='password_change_done']
accounts/ password_reset/ [name='password_reset']
accounts/ password_reset/done/ [name='password_reset_done']
accounts/ reset/<uidb64>/<token>/ [name='password_reset_confirm']
accounts/ reset/done/ [name='password_reset_complete']
```
#### Create templates
##### Login
###### Template
For this url path Django will automatically search `<prj name>/<app name>/templates/registration/login.html`.
In order to work, this template should contain at least a simple login form:
```django
<form method="post" action="{% url 'login' %}">
{% csrf_token %}
<table>
<tr>
    <td>{{ form.username.label_tag }}</td>
    <td>{{ form.username }}</td>
</tr>
<tr>
    <td>{{ form.password.label_tag }}</td>
    <td>{{ form.password }}</td>
</tr>
</table>
<input type="submit" value="login">
<input type="hidden" name="next" value="/where/to/redirect">
</form>
```
Apart from plain html for the input fields and submit button there are 3 mandatory things present:
1. **`action="{% url 'login' %}"`:**
    - The `action` attribute specifies where the form data will be sent when the form is submitted.
    - `{% url 'login' %}` is a template tag that generates the URL for the named URL pattern `'login'`. It means the form data will be sent to the URL associated with the `'login'` view.
2. **`{% csrf_token %}`:**
    - This is a template tag used to generate a [CSRF](https://docs.djangoproject.com/en/5.0/ref/csrf/#module-django.middleware.csrf) (Cross-Site Request Forgery) token.
    - CSRF tokens are used to protect against CSRF attacks.
    - CSRF attacks occur when a malicious website tricks a user's browser into making a request to a different website where the user is authenticated.
    - By including the `{% csrf_token %}` template tag, Django ensures that the form data is submitted only from your website and not from any other source.
    - In fact, if any post action happens without `{% csrf_token %}` tag - Django throws **403**.
3. **`<input type="hidden" name="next" value="/where/to/redirect">`:**
    - This is a hidden input field that stores the URL of the page the user was on before they tried to access a page that required authentication.
    - It's commonly used in login forms to redirect the user back to the page they were trying to access after they've logged in.
    - `name="next"` is the name of the input field, and `value` is a link to where client will be redirected after submitting a form.
The last `<input>` may be explicitly defaulted: `<input type="hidden" name="next" value="{{ next }}">` or not present at all. In both cases client will be redirected to the `<prj name>/<app name>/templates/registration/profile.html`. But we can override the default by adding to the `<prj name>/<prj name>/settings.py`:
```python
LOGIN_REDIRECT_URL = '/redirect/to/'
```
More on authentication views [here](https://docs.djangoproject.com/en/5.0/topics/auth/default/#all-authentication-views).
###### Application
Now, just to demonstrate, let's retrieve user's login and display welcome message.
As far as we are using *login* view from `django.contrib.auth.urls` - Django adds *User* to the *request* argument. So, to render user's login we can simply use `{{ request.user.username }}` tag.
##### Logout
Logout is much like login, but logout template (goodbye page) is arguably senseless, so instead of it we'll just redirect to the login page.
###### Form
Unlike login page we've made so far, logout will newer be accessed manually, so first we need to define a form that will send a logout request to Django.
In `<prj name>/<app name>/templates/chart.html`: 
```django
...
<form method="post" action="{% url 'logout' %}">
	{% csrf_token %}
	<button type="submit">Logout</button>
	<input type="hidden" name="next" value="{% url 'login' %}">
</form>
```
##### Sign Up
###### Template
In `<prj name>/<app name>/templates/registration/signup.html`: 
```django
    ...
    <form action="{% url 'signup' %}" method="post">
      {% csrf_token %}
      <div class="form-group">
        <label for="username">Username</label>
        <input type="text" id="id_username" name="username" required>
      </div>
      <div class="form-group">
        <label for="password">Password</label>
        <input type="password" id="id_password1" name="password1" required>
      </div>
      <div class="form-group">
        <label for="password">Confirm password</label>
        <input type="password" id="id_password2" name="password2" required>
      </div>
      <div class="form-group">
        <input type="submit" value="signup">
      </div>
    </form>
    ...
```
Important parts are:
- `action="{% url 'signup' %}"`: post form to the **signup** url
- *name*s and *id*s of the inputs are defined iv *view class*:
	-  `id="id_username" name="username"` for username
	- `id="id_password1" name="password1"` for first password input
	- `id="id_password2" name="password2"` to confirm password
- `type="submit" value="signup"` to submit the form
###### View
`SignUpView` is a class-based view that inherits from `CreateView`:
```python
from django.contrib.auth.forms import UserCreationForm
from django.views.generic import CreateView
from django.urls import reverse_lazy

class SignUpView(CreateView):
    form_class = UserCreationForm
    success_url = reverse_lazy("login")
    template_name = "registration/signup.html"
```
- [`CreateView`](https://docs.djangoproject.com/en/5.0/ref/class-based-views/generic-editing/#django.views.generic.edit.CreateView) is a generic view provided by Django to simplify the creation of new objects in a database. It's part of Django's class-based views and is particularly useful for handling forms where the primary action is creating a new object. It's API:
	- **`form_valid(form)`:**
	    - This method is called when the form is valid.
	    - You can override it to add custom behavior, such as sending email notifications or updating related objects.
	- **`get_context_data(**kwargs)`:**
	    - This method returns the context data for rendering the template.
	    - You can override it to add additional context data to the template.
- [reverse_lazy](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/#reverse-lazy) 
- `form_class`: This is the form class you want to use for user registration. In this case, you're using Django's built-in `UserCreationForm` form, which provides fields for `username`, `password1`, and `password2` used in the template.
- `success_url`: This is the URL where the user will be redirected after successfully registering. In this case, it's set to redirect to the login page.
- `template_name`: This is the name of the template used to render the signup form. In your case, it's `registration/signup.html`.
###### Url
```python
urlpatterns = [
	...
	path('signup/', views.SignUpView.as_view(), name="signup"),
]
```
Because we are using a class-based view - we need to pass it `as_view()` which is the method of the `CreateView`.
### Access restriction
Lets restrict access to `/chart`, so only logged in users could access it.
In `<prj name>/<app name>/views.py`:
```python
from django.contrib.auth.decorators import login_required

@login_required
def chart(request):
    ...

@login_required
def details(request, id):
    ...
```
Only authorized users can access views marked as `@login_required`.
If authorized users would try to access, let's say `http://localhost:8000/chart/details/1`, it will be auto-redirected to `http://localhost:8000/accounts/login/?next=/chart/details/1` - which is a login page with a `next` argument: right after login client will be redirected to the page he tried to access previously.
### [Bootstrap](https://getbootstrap.com/docs/5.3/getting-started/introduction/) integration
1. Install bootstrap into **venv**: `pip install django-bootstrap-v5`
2. Add bootstrap app in `<prj_name>/<prj_name>/settings.py`:
```python
INSTALLED_APPS = [  
    ...
    'bootstrap5',
]
```
3. Replace old css styles with [bootstrap](https://getbootstrap.com/docs/5.3/getting-started/introduction/) in `<prj_name>/<app_name>/templates/parent.html`:
```django
<!DOCTYPE html>  
<html>  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>{% block title %}{% endblock %}</title>  
    {% load bootstrap5 %}  
    {% bootstrap_css %}  
    {% bootstrap_javascript %}  
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">  
</head>  
<body>  
  
{% block content %}  
{% endblock %}  
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>  
</body>  
</html>
```
4. Rewrite the rest of templates :)
## Full-featured webpages
In order to make Django serve webpages which are using static files (css styles, images, etc) it needs to be configured for static content serving. *This only fits for tests and development! In the real-world only the web server (like Nginx) should serve static files*.
Let's assume that static files are arranged in the following way:
- `<project>/<app>/static/css/` for styles
- `<project>/<app>/static/js/` for scripts
- `<project>/<app>/static/aqssets/images` for rasters
- `<project>/<app>/static/aqssets/vectors` 
Now, let's instruct Django to serve static files. In `<project>/settings.py`:
```python
import os
...
INSTALLED_APPS = [
    ...
    'django.contrib.staticfiles',
    ...
]
...
STATIC_URL = 'static/'  
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
```
And then run: `py manage.py collectstatic`.
Django will create folder `staticfiles` in `<project>` folder and copy all files from `<app>/static` to `staticfiles`.
To access them from templates they need to be loaded first:
```django
{% extends "parent.html" %}  
{% load static %}
```
Then, to access `<app>/static/css/styles.css` just put the tag:
```django
{% static 'css/styles.css' %}
```
# Interfacing with NGINX
In real-world apps Interfacing with client and serving of the static content is done by nginx, which is exposed to the network. This topic is about coupling of the django project with nginx.
Important notes:
- All actions mentioned below are assumed to be done on the VM or a non-school Linux machine, assuming that later everything will be moved to the docker container.
- This step assumes that nginx is installed
- nginx is configured as follows:
	- nginx main directory is `/etc/nginx`.
	- nginx main config is `/etc/nginx/nginx.conf`.
	- `/etc/nginx/nginx.conf` has `include /etc/nginx/http.d/*.conf` directive in the *http* context, and therefore 
	- `/etc/nginx/http.d/` is a directory where we'll keep our custom `tran.conf` config.
Based on [this](https://www.digitalocean.com/community/tutorials/how-to-set-up-django-with-postgres-nginx-and-gunicorn-on-ubuntu) tutorial.

# Wrapping into Docker containers
## Django + nginx
The [docs](https://docs.djangoproject.com/en/5.0/howto/deployment/) state that one should expose a server (nginx) to the outside world for communication with a client and direct serving of the static content, while keeping django hidden behind it, occupied with DB communication and creation of the dynamic content.
This is what this module is all about.
## Overview
At this point, containerised app's structure looks like this:
```
.  
├── containers  
│   ├── db <comming soon...>  
│   ├── django  
│   │   ├── Dockerfile  
│   │   ├── requirements.txt  
│   │   └── <project>  
│   │       ├── db.sqlite3  
│   │       ├── manage.py
│   │       ├── media
│   │       │   └── avatars
│   │       ├── <app1>  
│   │       │   ├── admin.py  
│   │       │   ├── apps.py  
│   │       │   ├── __init__.py  
│   │       │   ├── migrations  
│   │       │   │   ├── 0001_initial.py  
│   │       │   │   └── __init__.py  
│   │       │   ├── models.py  
│   │       │   ├── signals.py  
│   │       │   ├── static  
│   │       │   │   └── assets  
│   │       │   │       ├── css  
│   │       │   │       │   └── ...  
│   │       │   │       ├── images  
│   │       │   │       │   └── ...  
│   │       │   │       ├── js  
│   │       │   │       │   └── ...  
│   │       │   │       └── vectors  
│   │       │   │           └── ...  
│   │       │   ├── templates  
│   │       │   │   ├── ...  
│   │       │   │   └── registration  
│   │       │   │       └── ...  
│   │       │   ├── tests.py  
│   │       │   ├── urls.py  
│   │       │   └── views.py  
│   │       ├── <app2>
│   │       │   └── ...
│   │       └── <project>  
│   │           ├── asgi.py  
│   │           ├── __init__.py  
│   │           ├── settings.py  
│   │           ├── urls.py  
│   │           └── wsgi.py  
│   └── nginx  
│       ├── conf  
│       │   └── nginx.conf  
│       └── Dockerfile  
└── docker-compose.yml
```
- `containers/django/<project>/requirements.txt` : list of python modules needed for django
- `containers/django/<project>/<app>/static/`: directory where all frontend files (except html's) should be kept.
- `containers/django/<project>/<app>/templates/`: directory for all htmls
## Docker-compose
For now django's embedded test DB is used, postgresql will be added later.
```yaml  
services:  
  django:  
    container_name: django  
    build:  
      context: ./containers/django  
      dockerfile: Dockerfile  
    expose:  
      - 8000  
    environment:  
      - ALLOWED_HOSTS=django  
      - DJANGO_SETTINGS_MODULE=simplified_prj.settings  
    networks:  
      - transcendence  
    volumes:  
      - static_volume:/var/static  
      - media_volume:/var/media  
  
  nginx:  
    container_name: nginx  
    build:  
      context: ./containers/nginx  
      dockerfile: Dockerfile  
    depends_on:  
      - django  
    ports:  
      - "8000:80"  
    networks:  
      - transcendence  
    volumes:  
      - ./containers/nginx/conf/:/etc/nginx/http.d/  
      - static_volume:/var/static  
      - media_volume:/var/media  
  
  
networks:  
  transcendence:  
    driver: bridge  
  
volumes:  
  static_volume:  
  media_volume:
```
- `django:expose`: django's container has only *8000* communication port open to the docker network and is inaccessible from outside
- `nginx:ports`: maps port of the container in the docker network **80** to the host's port **8000** - exposing container's interface.
- `static_volume:/var/static`: is a docker volume for the static files (css, js, images). All static files from all apps are getting combined here.
- `media_volume:/var/media`: volume to host avatars, so they will not interfere with static parts of the web pages
Django container start's first, and one of it's tasks is to prepare static files and media to be served by nginx. That includes static files for all apps present in django project, as well as for django's admin, which is like an implicit app.
## Django container
### Dockerfile
```dockerfile
FROM alpine:latest  
  
RUN apk update && apk upgrade && apk add --no-cache python3 py3-pip;  
  
ENV PYTHONDONTWRITEBYTECODE 1  
ENV PYTHONUNBUFFERED 1  
  
WORKDIR /app  
  
COPY simplified_prj ./  
COPY requirements.txt ./  
  
RUN pip3 install --no-cache-dir --break-system-packages -r requirements.txt && \  
    rm simplified_prj/settings_dev.py requirements.txt  
  
RUN python manage.py collectstatic  
RUN mv media /var/media/  
  
CMD ["daphne", "-b", "0.0.0.0", "-p", "8000", "simplified_prj.asgi:application"]
```
- *PYTHONDONTWRITEBYTECODE*:  Prevents Python from writing .pyc files to disc. This saves disk space and helps in avoiding stale or incorrect bytecode being read.
- *PYTHONUNBUFFERED*: Ensures that Python's standard output, stdin, and stderr are not buffered. This prevents delays in logging output.
- `python manage.py collectstatic`: collects all static files of all apps in directory specified in `<project>/settings.py`.
- **`CMD`**: we're using [daphne](https://pypi.org/project/daphne/) server to handle websocket requests via [channels](https://channels.readthedocs.io/en/latest/). This allows us to perform real-time interractions between client and django. 
### Settings
In `<project>/settings.py`:
```python
...
DEBUG = False
...
STATIC_URL = '/static/'
  
STATIC_ROOT = '/var/static' # static files will be collected here
```
`STATIC_URL = '/static/'`: this means that django tag `"{% static 'assets/css/styles.css' %}"` in the template will be replaced to `"/static/assets/css/styles.css"` in the rendered html.
In container:
```
/var/static/
├── admin
│   └── ...
└── assets
    └── ...
```
## NGINX container
### Dockerfile
```dockerfile
FROM alpine:latest  
  
RUN apk update && apk upgrade && apk add --no-cache nginx  
  
CMD ["nginx", "-g", "daemon off;"]
```
### Config
In `containers/nginx/conf/` mounted as `/etc/nginx/http.d/` in `nginx.conf`:
```nginx
server {  
    listen      80;  
    server_name localhost;  
    root        /var/static/;  
      
    location / {  
        proxy_pass http://django:8000;  
        proxy_set_header Host $http_host;  
        proxy_redirect off;  
        proxy_set_header X-Forwarded-For $remote_addr;  
        proxy_set_header X-Forwarded-Proto $scheme;  
        client_max_body_size 20m;  
    }  
  
    location /static/ {  
        alias /var/static/;  
    }  
}
```
Essentially, it means: forward all requests to `http://django:8000` unless they start with `/static/` - return requested file from `/var/static/` in this case.
## [Sessions](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Sessions)
Sessions are the mechanism keeping track of the "state" between the site and a particular browser.
Sessions can be accessed within a **view** from the `request` parameter (an `HttpRequest` passed in as the first argument to the view). This session attribute represents the specific connection to the current user (or to be more precise, the connection to the current _browser_, as identified by the session id in the browser's cookie for this site).
## Introducing complex models
Complex models are usually implemented as subclasses of `django.db.models.Model`, and can include fields, methods and metadata. The code fragment below shows a "typical" model, named `MyModelName`:
```python
from django.db import models
from django.urls import reverse

class MyModelName(models.Model):
    """A typical class defining a model, derived from the Model class."""

    # Fields
    my_field_name = models.CharField(max_length=20, help_text='Enter field documentation')
    # …

    # Metadata
    class Meta:
        ordering = ['-my_field_name']

    # Methods
    def get_absolute_url(self):
        """Returns the URL to access a particular instance of MyModelName."""
        return reverse('model-detail-view', args=[str(self.id)])

    def __str__(self):
        """String for representing the MyModelName object (in Admin site etc.)."""
        return self.my_field_name
```
More on [Fields](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Models#Fields), [Metadata](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Models#Metadata) and [Methods](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Models#Methods).
